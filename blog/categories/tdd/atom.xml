<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TDD | Louis Simoneau]]></title>
  <link href="http://lsimoneau.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://lsimoneau.github.io/"/>
  <updated>2014-05-03T18:24:08+08:00</updated>
  <id>http://lsimoneau.github.io/</id>
  <author>
    <name><![CDATA[Louis Simoneau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TDD Saved my Life (or at Least my Job)]]></title>
    <link href="http://lsimoneau.github.io/2014/05/03/tdd-saved-my-life-or-at-least-my-job/"/>
    <updated>2014-05-03T09:01:34+08:00</updated>
    <id>http://lsimoneau.github.io/2014/05/03/tdd-saved-my-life-or-at-least-my-job</id>
    <content type="html"><![CDATA[<p>There&rsquo;s been more than a little attention devoted lately to the value of TDD in software development, driven in large part by a <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">few</a> <a href="http://david.heinemeierhansson.com/2014/test-induced-design-damage.html">critical</a> <a href="http://david.heinemeierhansson.com/2014/slow-database-test-fallacy.html">blog posts</a> by DHH.</p>

<p>I disagree with most of what&rsquo;s said in those posts, but that&rsquo;s not why I&rsquo;m writing this. Others have already responded to the details of his arguments, for example the purported sacrifice of code clarity for testability, far better than I could. In particular, I can highly recommend <a href="http://blog.8thlight.com/uncle-bob/2014/05/01/Design-Damage.html">Uncle Bob&rsquo;s</a> and <a href="https://www.destroyallsoftware.com/blog/2014/tdd-straw-men-and-rhetoric">Gary Bernhardt&rsquo;s</a> responses.</p>

<p>But my personal experiences with TDD have highlighted a benefit of the technique that hasn&rsquo;t received much attention in the last few weeks' discussion, so I thought it worthwhile to share some of my experiences.</p>

<h2>TDD and Working Memory</h2>

<p>I&rsquo;ll begin with a little bit of background: I have a 14-month-old son who has yet to sleep through the night. This means that, with only a handfull of exceptions made possible by heroic efforts on the part of my partner, I haven&rsquo;t had a full night&rsquo;s sleep in over a year.</p>

<p>The effects of chronic sleep deprivation are myriad, but most notable to me in my day-to-day life as a software developer is that my working memory is shot to shit.</p>

<p>While I don&rsquo;t really have much more difficulty remembering facts, or marshalling my skills and experience to solve a problem, my ability to hold information relevant to the task at hand in my mind while I work is greatly reduced. This makes it quite a bit more difficult to implement any remotely non-trivial software system, since a big part of that process is maintaining at least a partial representation of the whole system in your mind as you work through building out and composing its individual parts.</p>

<p>This is where TDD comes in. As Katrina Owen astutely points out in her excellent talk <a href="http://www.youtube.com/watch?v=J4dlF0kcThQ">Therapeutic Refactoring</a>, <em>refactoring with tests makes you smarter</em>:</p>

<p><blockquote><p>You offload a bunch of those little details, that under normal circumstances go into working memory, into your tests. Once you start refactoring, you start reclaiming your brain.</p><footer><strong>Katrina Owen <a href="http://www.youtube.com/watch?v=J4dlF0kcThQ">http://www.youtube.com/watch?v=J4dlF0kcThQ</a> Therapeutic Refactoring</strong></footer></blockquote></p>

<p>TDD greatly reduces the demands that developing software places on your working memory, since you&rsquo;re in effect planting signposts for yourself as you go along, each one showing you the next step you need to take.</p>

<h2>Perfectly Spherical Programmers in a Vacuum</h2>

<p>I get it. You&rsquo;re smart. You&rsquo;re a good, nay a great programmer. On a good day, when your brain is firing on all cylinders, you can easily compose a complex subsystem without writing anything down, holding the whole thing in working memory as you effortlessly hop between collaborators, building out their integrations and implementations. Me too.</p>

<p>But even you, and definitely I, have lots of days that aren&rsquo;t so good. Sleep deprivation is only one of many possible reasons you might suffer from a temporary deficit of working memory. You could be distracted and worrying about a situation in your home or work life that has no bearing on the task at hand. You could be uncomfortable, too hot, too cold, hungry, sick, thirsty, upset, overfull, or god forbid hungover.</p>

<p>And in those situations, on those days, benefitting from what Katrina cleverly calls an <em>exobrain</em> is a life saver. You have a series of small, fast tests that have led you down the path of implementing your system right to the point you&rsquo;re at right now, in this second, deciding whether you need to write <code>&gt;</code> or <code>&lt;</code> in this conditional. So if you lose your train of thought or something slips your mind because you&rsquo;re not quite 100% today, don&rsquo;t worry. &ldquo;This is still red. Why is this red? Oh, I need to <em>X</em>.&rdquo; And you&rsquo;re right back at it.</p>

<p>It&rsquo;s no hyperbole for me to say that there&rsquo;s no way I could have kept myself employed over the past year without the help of this exobrain.</p>

<p>I truly believe that TDD helps you write better, less tightly coupled software. I believe that it protects you from bugs and regressions, and that it can be a huge help in refactoring your code to be more expressive and readable. But for me, this past year, I would still have practiced TDD even if none of those things were true. Because TDD is a reliable methodology for producing code that does what it&rsquo;s supposed to do. Because if you have sufficient knowledge of the language you&rsquo;re working in, the patterns of software design, and the domain of your application, you can apply that process and make good software even on the kind of day where you have a hard time making breakfast.</p>

<p>And on days when you <em>are</em> your very best, you still win. That extra working memory you now have available can be used to think about the high-level design of your system, the expresiveness of the method you&rsquo;re writing, <em>et cetera</em>. Because you&rsquo;ve grown accustomed to not trying to remember everything about the class you&rsquo;re working on and its collaborators, because <em>that information is in your tests</em>, you&rsquo;re free to use that extra mental RAM on more rewarding efforts.</p>

<h2>Keep your Skills Sharp for When your Brain Isn&rsquo;t</h2>

<p>Based on my experience this year, I now see this as one of the key benefits of TDD: it allows you to keep operating at a very nearly optimal performance level under much less than optimal circumstances. It&rsquo;s like a redundant backup system for your ability to do your job.</p>

<p>Even if you don&rsquo;t plan on having children, (or if you&rsquo;re one of those horrible people whose children sleep at night), there&rsquo;s a good chance you&rsquo;ll hit a point in your life when you&rsquo;re not your best, sometimes for weeks or months on end. Even if you&rsquo;ve tried TDD and thought it wasn&rsquo;t for you, even if you feel like you &ldquo;don&rsquo;t need it&rdquo;, I&rsquo;d urge you to get a bit more practice with it, because it just might come in handy someday if your brain lets you down.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Scroll Event Issues in Capybara/Poltergeist]]></title>
    <link href="http://lsimoneau.github.io/2014/01/12/debugging-scroll-event-issues-in-capybara-slash-poltergeist/"/>
    <updated>2014-01-12T08:22:00+08:00</updated>
    <id>http://lsimoneau.github.io/2014/01/12/debugging-scroll-event-issues-in-capybara-slash-poltergeist</id>
    <content type="html"><![CDATA[<p>I came across a particularly tricky issue with one of my integration tests using <a href="https://github.com/jnicklas/capybara">capybara</a> and <a href="https://github.com/jonleighton/poltergeist">poltergeist</a> this week, so I thought I&rsquo;d write it up for the benefit of anyone else encountering a similar problem.</p>

<h2>The Issue</h2>

<p>A key step in the workflow under test was clicking on a &ldquo;Publish&rdquo; button located at the bottom of the page. This test had been passing for some time, but started failing when we added a floating toolbar to the site.</p>

<p>The toolbar was of the type that appears as part of the document layout until the user scrolls past it, at which point it attaches itself to the top of the viewport.</p>

<p>The original code for the toolbar looked something like this:</p>

<p>``` coffeescript
$(document).ready &ndash;>
  toolbar = $(&lsquo;.toolbar&rsquo;)
  header  = $(&lsquo;.header&rsquo;)
  start   = toolbar.offset().top</p>

<p>  $.event.add(window, &ldquo;scroll&rdquo;, &ndash;></p>

<pre><code>pos = parseInt $(window).scrollTop()
toolbar.css("position", if pos &gt; start then "fixed" else "static")
header.css("padding-bottom", if pos &gt; start then toolbar.height() else 0)
</code></pre>

<p>  )
```</p>

<p>When scrolling past the toolbar, the <code>position</code> attribute is switched from <code>static</code> to <code>fixed</code>. Because this yanks the content in the toolbar out of the document flow, it causes the rest of the page to jump upwards to fill the now-empty space, so we apply padding to the header equal to the toolbar&rsquo;s height to compensate.</p>

<p>With this code in place, the test started failing. Some quick debugging showed that the click on the publish button just wasn&rsquo;t happening (no <code>click</code> events were fired). Usually, if Capybara can&rsquo;t find the element you&rsquo;ve told it to click on, it will throw an error, but in this case it was just failing silently. Remove the fixed toolbar, test goes green again.</p>

<h2>The Solution</h2>

<p>The key insight towards solving this issue came when I added debug code to the <code>scroll</code> event handler shown above. The page was actually scrolling during the execution of the test.</p>

<p><a href="https://github.com/jonleighton/poltergeist#mouseeventfailed-errors">Poltergeist&rsquo;s documentation</a> explains why:</p>

<blockquote><p>When Poltergeist clicks on an element, rather than generating a DOM click event, it actually generates a &ldquo;proper&rdquo; click. This is much closer to what happens when a real user clicks on the page &ndash; but it means that Poltergeist must scroll the page to where the element is, and work out the correct co-ordinates to click. If the element is covered up by another element, the click will fail (this is a good thing &ndash; because your user won&rsquo;t be able to click a covered up element either).</p></blockquote>

<p>The problem arises because of the way the fixed toolbar is implemented: <em>first</em> it pulls the toolbar out of the document flow, <em>then</em> it compensates with padding.</p>

<p>This results in two page redraws, and an imperceptibly fast jitter in the position of elements on the page. But since poltergeist is operating much faster than a human with a mouse, the time delay between scrolling the page and clicking the button (or, more accurately, clicking the coordinates where it expects the button to be) is negligible. As a result, it clicks while the page is jumping and misses the button.</p>

<p>There are a number of possible fixes here. It&rsquo;s possible to tell Poltergeist to just trigger a click event on the element rather than scrolling to it and clicking on its coordinates:</p>

<p><code>ruby
find_button("Save").trigger('click')
</code></p>

<p>Instead of:</p>

<p><code>
click_button "Save"
</code></p>

<p>This solves the problem, but does away with one of the main benefits of using Poltergeist in the first place: it directly emulates the behavior of a user navigation the site. If an element is covered up by something else, Poltergeist will be unable to click on it, just like a user.</p>

<p>The solution I ended up with was to change the implementation: rather than apply CSS to two different elements in quick succession, I apply a class to the page body. Because the padding is variable and needs to be toggled on and off in CSS only, I moved it to a shim element that&rsquo;s hidden by default. The body class both applies <code>fixed</code> position <em>and</em> unhides the shim:</p>

<p>``` coffeescript
shim    = $(&lsquo;.scroll-shim&rsquo;)
toolbar = $(&lsquo;.toolbar&rsquo;)
start   = toolbar.offset().top</p>

<p>$.event.add(window, &ldquo;scroll&rdquo;, &ndash;>
  pos = parseInt $(window).scrollTop()
  shim.css(&ldquo;padding-bottom&rdquo;, toolbar.height())</p>

<p>  $(&lsquo;body&rsquo;).toggleClass(&lsquo;scrolling-header&rsquo;, pos > start)
)
```</p>

<p>And in CSS:</p>

<p>```
.scroll-shim {
  display: none;
}</p>

<p>.toolbar {
  position: static;
}</p>

<p>.scrolling-header {
  .scroll-shim {</p>

<pre><code>display: block;
</code></pre>

<p>  }</p>

<p>  .toolbar {</p>

<pre><code>position: fixed;
</code></pre>

<p>  }
}
```</p>

<p>Because it only redraws the page once, this version doesn&rsquo;t cause content to jump around and allows Poltergeist to click on the button without issue. Although there&rsquo;s no perceptible difference when viewing the page, it <em>is</em> actually requiring the browser to do a bit less work, so it&rsquo;s even hypothetically possible that on slow hardware a user might see the benefit as well.</p>

<h2>Summary</h2>

<p>When using Poltergeist in combination with any JavaScript code that triggers off of <code>scroll</code> events, it&rsquo;s important to keep in mind that Poltergeist <em>will</em> scroll the page when required to get to an element you&rsquo;ve asked it to interact with. This isn&rsquo;t a bug, it&rsquo;s a feature: it allows for a closer emulation of a user interacting with your site, and might enable you to pick up issues that other drivers wouldn&rsquo;t surface.</p>

<p>However, if you&rsquo;re modifying the page in response to scroll events, you run the risk of introducing subtle race conditions like the one I&rsquo;ve described. In this particular case, there was a solution that improved both the performance of the page <em>and</em> the test behavior.</p>
]]></content>
  </entry>
  
</feed>
